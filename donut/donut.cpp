#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <glm/glm.hpp>
#include <SDL.h>
#undef main

constexpr int screen_w = 1920;
constexpr int screen_h = 1080;

constexpr uint32_t white = 0xFFFFFFFF;
constexpr uint32_t black = 0x00000000;
constexpr const char* win_title = "donut";
//one of the include has a define with some of these in it, so add 0 to the end
constexpr float left0 = -0.5f;
constexpr float right0 = 0.5f;
constexpr float bottom0 = -0.5f;
constexpr float top0 = 0.5f;
constexpr float near0 = 1.0f;
constexpr float far0 = 10.0f;

inline float deg2rad(float deg)
{
	//magic number is pi/180
	return (deg * 0.0174532925);
}

std::vector<glm::vec3> get_pts_on_circle(glm::vec3 origin, float radius, int num_pts)
{
	std::vector<glm::vec3> pts;
	for (int i = 0; i <= num_pts; i++)
	{
		float t = 360.f * i / num_pts;
		//pushback a vec3 point on circle
		pts.push_back({ origin.x + radius * cos(deg2rad(t)), origin.y + radius * sin(deg2rad(t)), 0.f });
	}
	return pts;
}

namespace disp
{
    constexpr int32_t g_kRenderDeviceFlags = -1;
    constexpr  int32_t g_kErrorOccurred = -1;

    int32_t e(int32_t result, std::string errorMessage)
    {
        if (result)
            std::cout << errorMessage;

        return result;
    }

    SDL_Window* CreateCenteredWindow(uint32_t width, uint32_t height, std::string title)
    {
        // Get current device's Display Mode to calculate window position
        SDL_DisplayMode DM;
        SDL_GetCurrentDisplayMode(0, &DM);

        // Calculate where the upper-left corner of a centered window will be
        const int32_t x = DM.w / 2 - width / 2;
        const int32_t y = DM.h / 2 - height / 2;

        // Create the SDL window
        SDL_Window* pWindow = SDL_CreateWindow(win_title, x, y, screen_w, screen_h,
            SDL_WINDOW_ALLOW_HIGHDPI);

        if (e(!pWindow, "Failed to create Window\n"));

        return pWindow;
    }

    // Create SDL renderer and configure whether or not to use Hardware Acceleration
    SDL_Renderer* CreateRenderer(SDL_Window* pWindow, bool hardwareAccelerated)
    {
        if (hardwareAccelerated)
            return SDL_CreateRenderer(pWindow, g_kRenderDeviceFlags, SDL_RENDERER_ACCELERATED);
        else
            return SDL_CreateRenderer(pWindow, g_kRenderDeviceFlags, SDL_RENDERER_SOFTWARE);
    }

    // Create an SDL Texture to use as a "back buffer"
    SDL_Texture* CreateBackBufferTexture(SDL_Renderer* pRenderer)
    {
        SDL_Texture* pTexture = SDL_CreateTexture(pRenderer, SDL_PIXELFORMAT_ARGB8888,
            SDL_TEXTUREACCESS_STREAMING, screen_w, screen_h);

        if (e(!pTexture, "Failed to create Back Buffer Texture\n"));

        return pTexture;
    }

    // Free resources 
    void Shutdown(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture)
    {
        // Free the Back Buffer
        if (ppTexture)
        {
            SDL_DestroyTexture(*ppTexture);
            *ppTexture = nullptr;
        }

        // Free the SDL renderer
        if (ppRenderer)
        {
            SDL_DestroyRenderer(*ppRenderer);
            *ppRenderer = nullptr;
        }

        // Free the SDL window
        if (ppWindow)
        {
            SDL_DestroyWindow(*ppWindow);
            *ppWindow = nullptr;
        }
        exit(-1);
    }

    // Initialize SDL Components 
    int32_t Startup(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture)
    {
        SDL_Init(SDL_INIT_VIDEO);

        if (e(!ppWindow, "Potiner to Window* was null\n")) return -1;

        *ppWindow = CreateCenteredWindow(screen_w, screen_h, win_title);

        if (e(!*ppWindow, "No Window. Aborting..."))
        {
            Shutdown(ppWindow, ppRenderer, ppTexture);

            return -1;
        }

        if (e(!ppRenderer, "Pointer to Renderer* was null\n")) return -1;

        *ppRenderer = CreateRenderer(*ppWindow, true);

        if (e(!ppRenderer, "No Renderer. Aborting..."))
        {
            Shutdown(ppWindow, ppRenderer, ppTexture);

            return -1;
        }

        if (e(!ppTexture, "Pointer to Texture* was null\n")) return -1;

        *ppTexture = CreateBackBufferTexture(*ppRenderer);

        if (e(!*ppTexture, "No back buffer Texture. Aborting..."))
        {
            Shutdown(ppWindow, ppRenderer, ppTexture);

            return -1;
        }

        return 0;
    }

    // Call this once during each render loop in order to determine when the user wishes to terminate the program
    bool ProcessInput()
    {
        // Return this value to tell the caller whether or not it should continue rendering
        // We will terminate the application if any key is pressed
        bool keepRenderLoopRunning = true;

        // Events are generated by SDL whenever something occurs system-wide
        // We are only interested in keyboard events and when the user closes the window
        // We will terminate the application if a key is pressed or if the window is manually closed
        SDL_Event event;

        // Process all events and return whether or not to quit
        while (SDL_PollEvent(&event))
        {
            // Handle relevant SDL events
            switch (event.type)
            {
                // Terminate application if a key is pressed or if the user closes the window
            case SDL_KEYDOWN:
            case SDL_QUIT:
                keepRenderLoopRunning = false;
            }
        }

        // Let the caller know if it should continue rendering, otherwise terminate
        return keepRenderLoopRunning;
    }


    // Call this within every render loop
    // Fills screen with randomly generated colored pixels
    int32_t Render(SDL_Window* pWindow, SDL_Renderer* pRenderer, SDL_Texture* pTexture, uint32_t* data)
    {
        // The Back Buffer texture may be stored with an extra bit of width (pitch) on the video card in order to properly
        // align it in VRAM should the width not lie on the correct memory boundary (usually four bytes).
        int32_t pitch = 0;

        // This will hold a pointer to the memory position in VRAM where our Back Buffer texture lies
        uint32_t* pPixelBuffer = nullptr;

        // Lock the memory in order to write our Back Buffer image to it
        if (!SDL_LockTexture(pTexture, NULL, (void**)&pPixelBuffer, &pitch))
        {
            // The pitch of the Back Buffer texture in VRAM must be divided by four bytes
            // as it will always be a multiple of four
            pitch /= sizeof(uint32_t);

            memcpy(pPixelBuffer, data, screen_h * static_cast<size_t>(pitch) * sizeof(uint32_t));

            // Unlock the texture in VRAM to let the GPU know we are done writing to it
            SDL_UnlockTexture(pTexture);

            // Copy our texture in VRAM to the display framebuffer in VRAM
            SDL_RenderCopy(pRenderer, pTexture, NULL, NULL);

            // Copy the VRAM framebuffer to the display
            SDL_RenderPresent(pRenderer);

            return 0;
        }
        else
            return g_kErrorOccurred;
    }
}

//namespace not strictly needed
namespace rot
{
	//rot pt about the x,y or z axis
	glm::vec3 pt_rot_x(glm::vec3 point, float deg)
	{
		float rx = deg2rad(deg);
		const glm::mat3x3 rot_mat = { {1.f, 0.f, 0.f},
									  {0.f, cos(rx), -sin(rx)},
									  {0.f, sin(rx), cos(rx)} };

		return (rot_mat * point);
	}

	glm::vec3 pt_rot_y(glm::vec3 point, float deg)
	{
		float ry = deg2rad(deg);
		const glm::mat3x3 rot_mat = { {cos(ry), 0, sin(ry)},
									  {0.f, 1.f, 0.f},
									  {-sin(ry), 0.f, cos(ry)} };

		return (rot_mat * point);
	}

	glm::vec3 pt_rot_z(glm::vec3 point, float deg)
	{
		float rz = deg2rad(deg);
		const glm::mat3x3 rot_mat = { {cos(rz), -sin(rz), 0.f},
									  {sin(rz), cos(rz), 0.f},
									  {0.f, 0.f, 1.f} };

		return  (rot_mat * point);
	}

	glm::vec3 pt_general_rot(glm::vec3 point, float deg_x, float deg_y, float deg_z)
	{
		float rx = deg2rad(deg_x);
		float ry = deg2rad(deg_y);
		float rz = deg2rad(deg_z);

		const glm::mat3x3 x_rot_mat = { {cos(rx), -sin(rx), 0.f},
										{sin(rx), cos(rx), 0.f},
										{0.f, 0.f, 1.f} };

		const glm::mat3x3 y_rot_mat = { {cos(ry), 0.f, sin(ry)},
										{0.f, 1.f, 0.f},
										{-sin(ry), 0.f, cos(ry)} };
		
		const glm::mat3x3 z_rot_mat = { {1.f, 0.f, 0.f},
										{0.f, cos(rz), -sin(rz)},
										{0.f, sin(rz), cos(rz)} };

		return (x_rot_mat * y_rot_mat * z_rot_mat * point);
	}

	void change_pt_general_rot(glm::vec3 *point, float deg_x, float deg_y, float deg_z)
	{
		float rx = deg2rad(deg_x);
		float ry = deg2rad(deg_y);
		float rz = deg2rad(deg_z);

		const glm::mat3x3 x_rot_mat = { {cos(rx), -sin(rx), 0.f},
										{sin(rx), cos(rx), 0.f},
										{0.f, 0.f, 1.f} };

		const glm::mat3x3 y_rot_mat = { {cos(ry), 0.f, sin(ry)},
										{0.f, 1.f, 0.f},
										{-sin(ry), 0.f, cos(ry)} };

		const glm::mat3x3 z_rot_mat = { {1.f, 0.f, 0.f},
										{0.f, cos(rz), -sin(rz)},
										{0.f, sin(rz), cos(rz)} };

		*point = (x_rot_mat * y_rot_mat * z_rot_mat * (*point));
	}
}

inline float pow2(float x)
{
	return x * x;
}

inline float pt_dist_3d(glm::vec3 a, glm::vec3 b)
{
    return std::powf((pow2(b.x - a.x) + pow2(b.y - a.y) + pow2(b.z - a.z)), 0.5f);
}
//vec3 a is light src, b is pt, light_value is strength of src
inline float light_intensity(float light_value, glm::vec3 a, glm::vec3 b)
{
    return light_value * (1.f / pow2(pt_dist_3d(a, b)));
}

/*
params:
vec3 pt - point to be projected
vec3 cam_pos - 3d pos of cam
vec3 cam_ori - orientation of cam (tait-bryan angles)
vec3 dis_pos - display surface pos rel to cam pinhole
vec3 ccd - x,y recording surface size , z distance from the recording surface to the entrance pupil 

global constants: screen_w, screen_h
*/
glm::vec2 perspective_projection(glm::vec3 pt, glm::vec3 cam_pos, glm::vec3 cam_ori, glm::vec3 dis_pos, glm::vec3 ccd)
{
	const glm::mat3x3 mat0 = { {1, 0, 0},
							   {0, cos(cam_ori.x), sin(cam_ori.x)},
							   {0, -sin(cam_ori.x), cos(cam_ori.x)} };

	const glm::mat3x3 mat1 = { {cos(cam_ori.y), 0, -sin(cam_ori.y)},
							   {0, 1, 0},
							   {sin(cam_ori.y), 0, cos(cam_ori.y)} };

	const glm::mat3x3 mat2 = { {cos(cam_ori.z), sin(cam_ori.z), 0},
							   {-sin(cam_ori.z), cos(cam_ori.z), 0},
							   {0, 0, 1} };

	 const glm::vec3 d = (mat0 * mat1 * mat2 * (pt - cam_pos));

	 return { (d.x * screen_w) / (d.z * ccd.x) * ccd.x,
			  (d.y * screen_h) / (d.z * ccd.y) * ccd.z };
}


int main()
{
    uint32_t* data = new uint32_t[screen_w * screen_h];


    SDL_Window* pWindow = nullptr;
    SDL_Renderer* pRenderer = nullptr;
    SDL_Texture* pTexture = nullptr;

    if (disp::e(disp::Startup(&pWindow, &pRenderer, &pTexture), "Startup Failed. Aborting...\n"))
    {
        disp::Shutdown(&pWindow, &pRenderer, &pTexture);
        return -1;
    }

	//create torus
    const int pointdensity = 200;
	std::vector<glm::vec3> torus;
	glm::vec3 origin = { 75, 0, 75 };
	std::vector<glm::vec3> circle = get_pts_on_circle(origin, 45, pointdensity);
    for (int i = 0; i <= 360; i += (360 / pointdensity))
    {
        for (glm::vec3& point : circle)
        {
            torus.push_back(rot::pt_rot_y(point, i));
        }
    }

	int x, y;
    const glm::vec3 light_loc = { 260, 500, 290 };
    const glm::vec3 cam_loc = { 250, 200, 250 };
    const glm::vec3 tba = { 0.3 , -0.3 , 0 };
    const glm::vec3 dis = { 1 , 0, 1 };
    const glm::vec3 ccd = { 10, 10, 15 };

	for (;;)
	{
		for (int jj = 0; jj < (screen_w * screen_h); jj++)
		{
			data[jj] = black;
		}

		for (glm::vec3& pt : torus)
		{
			rot::change_pt_general_rot(&pt, 1, 0, 0);
			
			glm::vec2 pixel = perspective_projection(pt, cam_loc, tba, dis, ccd);

			x = round(pixel.x);
			y = round(pixel.y);
            y = std::clamp(y, 0, screen_h-1);
            x = std::clamp(x, 0, screen_w-1);
            
			data[x + (y * screen_w)] = white;
		}
        disp::Render(pWindow, pRenderer, pTexture, data);
	}

	return 0;
}